Potential Shaders:

1. Leaf Wind: Geometry Shader
* Update leaf orientation due to wind or object collisions
+ Major performance limiter
- Requires high res wind map/texture
- Per-frame per-object orientation calculation + timestamp

<Completed> 2. Leaf Transparency: Vertex/Fragment Shader
* Multiply normal by -0.5 if player is viewing the leaf side facing away from the light source
* Multiply normal by -1.0 instead if the sun is behind the leaf
+ Should be simple, only modifies normal

3. Grass Effects/Regen (crush, burn, cut, update z): Geometry Shader
* Modify leaf pos/orient/length/color based on parameters
* Merge back to nominal value at certain realtime rates
+ Adds realism to scene
- Requires lots of per-triangle input values and extra copies of pos/orient/color
- Requires timestamp, and must update even if not visible
- Likely a performance bottleneck

4. Cobj Lighting: Vertex/Fragment Shader
* Apply shadows and lighting for each light source on each vertex
* Lookup dynamic lights and colors
+ Major performance limiter
+ Interpolation allows better lighting quality
+ Entirely replaces per-pixel operations
- May be too complex/inefficient for a vertex shader due to tree/grid/voxel lookups and iteration
- Requires many different per-vertex parameters
- Will not take advantage of display lists/caching

5. Ship Rendering: Vertex/Fragment Shader or Geometry Shader
* Add per-ship lighting with possibly unlimited number of light sources
* Possibly better ship shadows
+ Could improve both performance and lighting quality
- May require a different shader per ship type, or disabling the shader for some types
- Lots of per-ship data, case splits, and LOD makes this complex
- Likely too slow to load a shader per-ship, and if sorting ships by type alpha blending will be incorrect

6. Water Reflections: Vertex/Fragment Shader
* Apply sun/cloud/landscape/tree/objects reflection on water surface (and maybe refraction)
* Possibly also ripples
+ Major performance limiter
+ Higher quality reflections
- Requires complex tree/grid traversal algorithm, and line/obj intersections
- Dynamic object data changes per frame (including clouds)
- May hit shader size limits or be too slow for a fragment shader
- Using a pixel shader will only improve performance (not quality)

7. Mesh Texturing: Vertex/Fragment Shader
* Apply a height/slope/water dependent texture to the mesh based on blending source textures
+ Significant memory reduction due to generation of texture on the fly vs. precalc/storage
+ Performance improvement in scrolling and mesh tiles
- May be too slow, even with partial precomputation
- Texture lookups may exceed fragment shader maximum (5 vs. 4?)
- Where do the constants and water depth parameters come from?

8. Mesh Underwater Caustics: Vertex/Fragment Shader
* Apply dynamic water caustics on underwater mesh
+ Improved performance and quality of caustics (though may be less noticeable)
- Algorithm requires both mesh and water and has a global solution
- May be too slow or complex for a fragment shader

<Completed> 9. Snowflakes: Geometry Shader using billboards
* Render snow pixels as textured snowflakes
+ Good simple practice geometry shader
- Performance and quality may not change much

10. Smoke/Clouds and/or Fires: Vertex/Fragment Shader, or Geometry Shader using billboards
* Render smoke and cloud particles and/or fires faster or with better
quality/blending/lighting
+ Lots of possibilities here, plenty of research done on this topic
- Not sure what to do yet, or if the improvements would be significant

Finished: 2, 9
Improved Render Time: 1, 2, 3, 4, 5, 6, 8
Improved Memory: 7, 3?
Improved Quality: 8, 10, 4?, 5?, 6?

Difficult: 4, 5, 6, maybe 3, 7, 10

Geom Shader: 1, 3, 5, 9
Vertex/Fragment Shader: 2, 4, 5, 6, 7, 8, 10