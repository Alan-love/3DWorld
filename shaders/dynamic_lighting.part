uniform vec3 scene_llc, scene_scale; // scene bounds (world space)
uniform vec3 camera_pos; // world space
uniform sampler2D dlight_tex;
uniform usampler2D dlelm_tex, dlgb_tex;

const float SPOTLIGHT_LEAKAGE = 0.0; // simulates indirect lighting - however, doesn't match dlights XY grid, so has artifacts, and doesn't look right
const float SHADOW_LEAKAGE    = 0.1; // simulates indirect lighting

#ifdef HAS_DLIGHT_SMAP
const int MAX_DLIGHT_SMAPS = 16;
uniform sampler2DShadow smap_tex_dl[MAX_DLIGHT_SMAPS];
uniform mat4 smap_matrix_dl[MAX_DLIGHT_SMAPS];
#endif

const float LT_DIR_FALLOFF = 0.005;

float get_dir_light_scale(in vec3 pos, in vec3 lpos, in vec3 dir, in float bwidth) {
	vec3 obj_dir  = normalize(lpos - pos);
	float dp      = dot(obj_dir, (2.0*dir - 1.0)); // map dir [0,1] to [-1,1]
	float dp_norm = 0.5*(1.0 - dp); // dp = -1.0 to 1.0, bw = 0.0 to 1.0
	float v       = clamp(2.0*(dp_norm + bwidth + LT_DIR_FALLOFF - 1.0)/LT_DIR_FALLOFF, 0.0, 1.0);
	return mix(smoothstep(0.0, 1.0, v), 1.0, SPOTLIGHT_LEAKAGE);
}

float get_point_intensity_at(in vec3 pos, in vec3 lpos, in float radius) { // Note: doesn't handle the radius==0 case
	float rscale = max(0.0, (radius - distance(pos, lpos)))/radius;
	return rscale*rscale; // quadratic 1/r^2 attenuation
}

float get_sphere_intensity_at(in vec3 pos, in vec3 lpos, in float radius, in float inner_radius) { // Note: doesn't handle the radius==0 case
	float rscale = clamp((radius - distance(pos, lpos))/(radius - inner_radius), 0.0, 1.0);
	return rscale*rscale; // quadratic 1/r^2 attenuation
}

float get_line_intensity_at(in vec3 pos, in vec3 lpos1, in vec3 lpos2, in float radius, out vec3 lpos) { // Note: doesn't handle the radius==0 case
	vec3 L = (lpos2 - lpos1);
	lpos   = lpos1 + L*clamp(dot((pos - lpos1), L)/dot(L,L), 0.0, 1.0);
	float rscale = max(0.0, (radius - distance(lpos, pos)))/radius; // use point-to-line distance
	return rscale*rscale; // quadratic 1/r^2 attenuation
}

//float get_sphere_intensity_at(in vec3 pos, in vec3 lpos, in float sradius, in float radius) {}

vec3 apply_power_signed(in vec3 val, in float n) {
	return sign(val)*pow(abs(val), vec3(n)); // preserve the sign
}

#ifndef NO_SHADOW_MAP
// Note: for non-spotlights where the shadow frustum doesn't cover the entire light angle,
// the lookup is clamped to the edge texel of the shadow map, which stretches the shadow to the sides;
// it may make more sense to clip the shadower to the frustum so that all the area outside the shadow frustum is unshadowed,
// but it's not clear how to do that cleanly/efficiently or if it would look any better
float get_shadow_map_weight_dl(in vec4 pos, in vec3 normal, in mat4 matrix, in sampler2DShadow sm_tex) {
	pos.xyz += norm_bias_scale*z_bias*normal; // world space
	vec4 shadow_coord = matrix * pos;
	shadow_coord.z   += -z_bias*shadow_coord.w;
	return mix(textureProj(sm_tex, shadow_coord), 1.0, SHADOW_LEAKAGE); // allow a small amount of transmitted light to simulate indirect lighting
}
#endif

void add_dlights_bm_scaled(inout vec3 color, in vec3 dlpos, in vec3 normal, in vec3 diff_color, in float bump_map_normal_scale) {
#ifndef NO_DYNAMIC_LIGHTS

#if defined(USE_BUMP_MAP_DL) && !defined(BUMP_MAP_CUSTOM)
	mat3 TBN = get_tbn(1.0);
#endif
	const float gamma = 2.2;
	vec3 dl_color = vec3(0.0);

	vec2 norm_pos = clamp((dlpos.xy - scene_llc.xy)/scene_scale.xy, 0.0, 1.0); // should be in [0.0, 1.0] range
	uint gb_ix  = texture(dlgb_tex, norm_pos).r; // get grid bag element index range (uint32)
	uint st_ix  = (gb_ix & 0xFFFFFFU); // 24 low bits
	uint num_ix = ((gb_ix >> 24U) & 0xFFFFFFU); // 8 high bits
	uint end_ix = st_ix + num_ix;
	const uint elem_tex_x = (1<<8);  // must agree with value in C++ code, or can use textureSize()
	
	for (uint i = st_ix; i < end_ix; ++i) { // iterate over grid bag elements
		uint dl_ix  = texelFetch(dlelm_tex,  ivec2((i%elem_tex_x), (i/elem_tex_x)), 0).r; // get dynamic light index (uint16)
		vec4 lpos_r = texelFetch(dlight_tex, ivec2(0, dl_ix), 0); // light center, radius
		lpos_r.xyz *= scene_scale; // convert from [0,1] back into world space
		lpos_r.xyz += scene_llc;
		lpos_r.w   *= 0.5*scene_scale.x;
#if !defined(USE_BUMP_MAP_DL) || defined(BUMP_MAP_CUSTOM)
		// not valid for line lights
		// causes problems with bump mapping TBN for some reason?
		if (abs(dlpos.z - lpos_r.z) > lpos_r.w) continue; // hurts in the close-up case but helps in the distant case
#endif
		vec4 lcolor     = texelFetch(dlight_tex, ivec2(1, dl_ix), 0); // light color
		lcolor.rgb     *= 10.0; // unscale color
		lcolor.rgb      = 2.0*lcolor.rgb - 1.0; // map [0,1] to [-1,1] for negative light support

#if defined(HAS_LINE_LIGHTS) || defined(HAS_SPOTLIGHTS)
		// fetch another texture block which contains some combination of dir, bw, and lpos2
		vec4 dir_w = texelFetch(dlight_tex, ivec2(2, dl_ix), 0); // {light direction, beamwidth} - OR - {light pos 2, 0.0}
#endif

		float intensity;
#ifdef HAS_LINE_LIGHTS // technically cylinder light
		if (dir_w.w == 0.0) { // this is a line light
			vec3 lpos2 = dir_w.xyz*scene_scale + scene_llc; // other end point of line
			intensity  = get_line_intensity_at(dlpos, lpos_r.xyz, lpos2, lpos_r.w, lpos_r.xyz); // put the point used for lighting into lpos_r.xyz
		}
		else { // point light
#else
		if (true) { // always a point light
#endif
			intensity = get_point_intensity_at(dlpos, lpos_r.xyz, lpos_r.w);
			//intensity = get_sphere_intensity_at(dlpos, lpos_r.xyz, lpos_r.w, 0.1*lpos_r.w);
#ifdef HAS_SPOTLIGHTS
			intensity *= get_dir_light_scale(dlpos, lpos_r.xyz, dir_w.xyz, dir_w.w);
#endif
		}
		vec3 eye_dir   = normalize(camera_pos - dlpos);
		vec3 light_dir = normalize(lpos_r.xyz - dlpos);
#ifdef USE_BUMP_MAP_DL
		vec3 orig_ldir = light_dir;
		vec3 lpos_eye  = (fg_ModelViewMatrix * vec4(lpos_r.xyz, 1.0)).xyz; // convert from world to eye to tangent space
		float nscale   = clamp(10.0*dot(normal, light_dir), 0.0, 1.0); // fix self-shadowing
		light_dir      = normalize(lpos_eye - epos.xyz);
#ifdef BUMP_MAP_CUSTOM
		vec3 lnorm     = nscale*apply_bump_map(light_dir, eye_dir);
#else
		vec3 lnorm     = nscale*apply_bump_map_for_tbn(light_dir, eye_dir, TBN);
#endif // BUMP_MAP_CUSTOM
		if (dot(eye_dir, lnorm) < 0.0) {eye_dir = -eye_dir;} // better, but still not completely correct
		float n_dot_l  = mix(dot(normal, orig_ldir), dot(lnorm, light_dir), bump_map_normal_scale);
#else // !USE_BUMP_MAP_DL
		vec3 lnorm     = normal;
		float n_dot_l  = dot(lnorm, light_dir);
#endif // USE_BUMP_MAP_DL
		float diff_mag = max(0.0, n_dot_l); // diffuse
#ifndef NO_DL_SPECULAR
		float spec_mag = clamp(10.0*n_dot_l, 0.0, 1.0)*get_spec_intensity(lnorm, light_dir, eye_dir);
#else
		float spec_mag = 0.0;
#endif // NO_DL_SPECULAR
		vec3 spec_color= specular_color.rgb;
#ifdef USE_SPEC_MAP
		spec_color    *= get_spec_color();
#endif

#if defined(HAS_DLIGHT_SMAP) && !defined(NO_SHADOW_MAP) // Note: all math is in world space
		int smap_index = int(texelFetch(dlight_tex, ivec2(3, dl_ix), 0).r*MAX_DLIGHT_SMAPS);
		if (smap_index > 0) { // has a shadow map
			intensity *= get_shadow_map_weight_dl(vec4(dlpos, 1.0), lnorm, smap_matrix_dl[smap_index-1], smap_tex_dl[smap_index-1]);
		}
#endif
		// FIXME: specular should have a lower falloff and its own intensity - however, this will require a larger radius and impact performance
		vec3 add_color = lcolor.rgb * (spec_color*spec_mag + diff_color*diff_mag) * (lcolor.a * intensity);
		dl_color += apply_power_signed(add_color, gamma); // add in linear space
	} // for i
	color  = apply_power_signed(color, gamma); // to linear space
	color += gamma*min(dl_color, 1.0); // add dlights color
	color  = apply_power_signed(color, 1.0/gamma); // back to normal color space
#endif // NO_DYNAMIC_LIGHTS
}

void add_dlights(inout vec3 color, in vec3 dlpos, in vec3 normal, in vec3 diff_color) {add_dlights_bm_scaled(color, dlpos, normal, diff_color, 1.0);}
