uniform vec3 scene_llc, scene_scale; // scene bounds (world space)
uniform sampler2D dlight_tex;
uniform usampler2D dlelm_tex, dlgb_tex;

const float LT_DIR_FALLOFF = 0.005;


float get_dir_light_scale(in vec3 pos, in vec3 lpos, in vec3 dir, in float bwidth) {
	vec3 obj_dir  = normalize(lpos - pos);
	float dp      = dot(obj_dir, (2.0*dir - 1.0)); // map dir [0,1] to [-1,1]
	float dp_norm = 0.5*(1.0 - dp); // dp = -1.0 to 1.0, bw = 0.0 to 1.0
	return clamp(2.0*(dp_norm + bwidth + LT_DIR_FALLOFF - 1.0)/LT_DIR_FALLOFF, 0.0, 1.0);
}

float get_intensity_at(in vec3 pos, in vec3 lpos, in float radius) { // Note: doesn't handle the radius==0 case
	float rscale = max(0.0, (radius - distance(pos, lpos)))/radius;
	return rscale*rscale; // quadratic 1/r^2 attenuation
}

vec3 add_dlights(in vec3 dlpos, in vec3 normal, in vec3 eye) {
	vec2 norm_pos = clamp((dlpos.xy - scene_llc.xy)/scene_scale.xy, 0.0, 1.0); // should be in [0.0, 1.0] range

	vec3 color  = vec3(0,0,0);
	uint gb_ix  = texture2D(dlgb_tex, norm_pos).r; // get grid bag element index range (uint32)
	uint st_ix  = (gb_ix & 0xFFFFU);
	uint end_ix = ((gb_ix >> 16U) & 0xFFFFU);
	const uint elem_tex_sz = 256;  // must agree with value in C++ code, or can use textureSize()
	const uint max_dlights = 1024; // must agree with value in C++ code, or can use textureSize()
	
	for (uint i = st_ix; i < end_ix; ++i) { // iterate over grid bag elements
		uint dl_ix  = texelFetch(dlelm_tex,  ivec2((i%elem_tex_sz), (i/elem_tex_sz)), 0).r; // get dynamic light index (uint16)
		vec4 lpos_r = texelFetch(dlight_tex, ivec2(0, dl_ix), 0); // light center, radius
		lpos_r.xyz *= scene_scale; // convert from [0,1] back into world space
		lpos_r.xyz += scene_llc;
		lpos_r.w   *= 0.5*scene_scale.x;
		//if (abs(dlpos.z - lpos_r.z) > lpos_r.w) continue; // hurts in the close-up case but helps in the distant case
		vec4 lcolor     = texelFetch(dlight_tex, ivec2(1, dl_ix), 0); // light color
		lcolor.rgb     *= 10.0; // unscale color
		lcolor.rgb      = 2.0*lcolor.rgb - 1.0; // map [0,1] to [-1,1] for negative light support
		float intensity = get_intensity_at(dlpos, lpos_r.xyz, lpos_r.w);
		
		if (has_dir_lights) {
			vec4 dir_w = texelFetch(dlight_tex, ivec2(2, dl_ix), 0); // light direction, beamwidth
			intensity *= get_dir_light_scale(dlpos, lpos_r.xyz, dir_w.xyz, dir_w.w);
		}
#ifdef USE_BUMP_MAP
		vec3 lpos_eye  = (gl_ModelViewMatrix * vec4(lpos_r.xyz, 1.0)).xyz; // convert from world to eye to tangent space
		vec3 light_dir = normalize(lpos_eye - epos.xyz);
		vec3 lnorm     = apply_bump_map(light_dir);
		vec3 eye_pos   = normalize(-ts_pos);
#else
		vec3 light_dir = normalize(lpos_r.xyz - dlpos);
		vec3 eye_pos   = normalize(eye - dlpos);
		vec3 lnorm     = normal;
#endif
		vec3 half_vect = normalize(eye_pos + light_dir); // Eye + L (in world space)
		float n_dot_l  = dot(lnorm, light_dir);
		float diff_mag = max(0.0, n_dot_l); // diffuse
		float spec_mag = (n_dot_l > 0.0 ? 1.0 : 0.0)*pow(max(dot(lnorm, half_vect), 0.0), gl_FrontMaterial.shininess);
		vec3 spec_color= gl_FrontMaterial.specular.rgb;
#ifdef USE_SPEC_MAP
		spec_color    *= get_spec_color();
#endif
		color += lcolor.rgb * (spec_color*spec_mag + vec3(1,1,1)*diff_mag) * (lcolor.a * intensity);
	}
	return min(color, 1.0);
}
