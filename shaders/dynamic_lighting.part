uniform vec3 scene_llc, scene_scale; // scene bounds (world space)
uniform vec3 camera_pos; // world space
uniform sampler2D dlight_tex;
uniform usampler2D dlelm_tex, dlgb_tex;

const float LT_DIR_FALLOFF = 0.005;

float get_dir_light_scale(in vec3 pos, in vec3 lpos, in vec3 dir, in float bwidth) {
	vec3 obj_dir  = normalize(lpos - pos);
	float dp      = dot(obj_dir, (2.0*dir - 1.0)); // map dir [0,1] to [-1,1]
	float dp_norm = 0.5*(1.0 - dp); // dp = -1.0 to 1.0, bw = 0.0 to 1.0
	float v       = clamp(2.0*(dp_norm + bwidth + LT_DIR_FALLOFF - 1.0)/LT_DIR_FALLOFF, 0.0, 1.0);
	return smoothstep(0.0, 1.0, v);
}

float get_point_intensity_at(in vec3 pos, in vec3 lpos, in float radius) { // Note: doesn't handle the radius==0 case
	float rscale = max(0.0, (radius - distance(pos, lpos)))/radius;
	return rscale*rscale; // quadratic 1/r^2 attenuation
}

float get_line_intensity_at(in vec3 pos, in vec3 lpos1, in vec3 lpos2, in float radius, out vec3 lpos) { // Note: doesn't handle the radius==0 case
	vec3 L = (lpos2 - lpos1);
	lpos   = lpos1 + L*clamp(dot((pos - lpos1), L)/dot(L,L), 0.0, 1.0);
	float rscale = max(0.0, (radius - distance(lpos, pos)))/radius; // use point-to-line distance
	return rscale*rscale; // quadratic 1/r^2 attenuation
}

//float get_sphere_intensity_at(in vec3 pos, in vec3 lpos, in float sradius, in float radius) {}

vec3 add_dlights(in vec3 dlpos, in vec3 normal, in vec3 diff_color) {
	vec3 color = vec3(0.0);
#ifndef NO_DYNAMIC_LIGHTS
	vec2 norm_pos = clamp((dlpos.xy - scene_llc.xy)/scene_scale.xy, 0.0, 1.0); // should be in [0.0, 1.0] range
	uint gb_ix  = texture(dlgb_tex, norm_pos).r; // get grid bag element index range (uint32)
	uint st_ix  = (gb_ix & 0xFFFFFFU); // 24 low bits
	uint num_ix = ((gb_ix >> 24U) & 0xFFFFFFU); // 8 high bits
	uint end_ix = st_ix + num_ix;
	const uint elem_tex_x = (1<<8);  // must agree with value in C++ code, or can use textureSize()
	
	for (uint i = st_ix; i < end_ix; ++i) { // iterate over grid bag elements
		uint dl_ix  = texelFetch(dlelm_tex,  ivec2((i%elem_tex_x), (i/elem_tex_x)), 0).r; // get dynamic light index (uint16)
		vec4 lpos_r = texelFetch(dlight_tex, ivec2(0, dl_ix), 0); // light center, radius
		lpos_r.xyz *= scene_scale; // convert from [0,1] back into world space
		lpos_r.xyz += scene_llc;
		lpos_r.w   *= 0.5*scene_scale.x;
		if (abs(dlpos.z - lpos_r.z) > lpos_r.w) continue; // hurts in the close-up case but helps in the distant case (not valid for line lights)
		vec4 lcolor     = texelFetch(dlight_tex, ivec2(1, dl_ix), 0); // light color
		lcolor.rgb     *= 10.0; // unscale color
		lcolor.rgb      = 2.0*lcolor.rgb - 1.0; // map [0,1] to [-1,1] for negative light support

#if defined(HAS_LINE_LIGHTS) || defined(HAS_SPOTLIGHTS)
		// fetch another texture block which contains some combination of dir, bw, and lpos2
		vec4 dir_w = texelFetch(dlight_tex, ivec2(2, dl_ix), 0); // {light direction, beamwidth} - OR - {light pos 2, 0.0}
#endif
		float intensity;
#ifdef HAS_LINE_LIGHTS // technically cylinder light
		if (dir_w.w == 0.0) { // this is a line light
			vec3 lpos2 = dir_w.xyz*scene_scale + scene_llc; // other end point of line
			intensity  = get_line_intensity_at(dlpos, lpos_r.xyz, lpos2, lpos_r.w, lpos_r.xyz); // put the point used for lighting into lpos_r.xyz
		}
		else { // point light
#else
		if (true) { // always a point light
#endif
			intensity = get_point_intensity_at(dlpos, lpos_r.xyz, lpos_r.w);
#ifdef HAS_SPOTLIGHTS
			intensity *= get_dir_light_scale(dlpos, lpos_r.xyz, dir_w.xyz, dir_w.w);
#endif
		}
		vec3 eye_pos   = camera_pos - dlpos;
		vec3 light_dir = normalize(lpos_r.xyz - dlpos);
#ifdef USE_BUMP_MAP_DL
		vec3 lpos_eye  = (fg_ModelViewMatrix * vec4(lpos_r.xyz, 1.0)).xyz; // convert from world to eye to tangent space
		float nscale   = clamp(10.0*dot(normal, light_dir), 0.0, 1.0); // fix self-shadowing
		light_dir      = normalize(lpos_eye - epos.xyz);
		vec3 lnorm     = nscale*apply_bump_map(light_dir, eye_pos);
		eye_pos        = -eye_pos; // ???
#else
		vec3 lnorm     = normal;
#endif // USE_BUMP_MAP_DL

		float n_dot_l  = dot(lnorm, light_dir);
		float diff_mag = max(0.0, n_dot_l); // diffuse

#ifndef NO_DL_SPECULAR
		vec3 half_vect = normalize(normalize(eye_pos) + light_dir); // Eye + L (in world space)
		float spec_mag = clamp(10.0*n_dot_l, 0.0, 1.0)*pow(clamp(dot(lnorm, half_vect), 0.0001, 1.0), get_shininess());
#else
		float spec_mag = 0.0;
#endif // NO_DL_SPECULAR
		vec3 spec_color= specular_color.rgb;
#ifdef USE_SPEC_MAP
		spec_color    *= get_spec_color();
#endif
		color += lcolor.rgb * (spec_color*spec_mag + diff_color*diff_mag) * (lcolor.a * intensity);
	}
#endif
	return min(color, 1.0);
}
