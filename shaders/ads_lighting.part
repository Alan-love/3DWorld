vec4 add_light_specular_fast(in vec3 normal, in int i) {
	float NdotHV = max(dot(normal, normalize(gl_LightSource[i].halfVector.xyz)), 0.0);
	return gl_FrontLightProduct[i].specular * pow(NdotHV, gl_FrontMaterial.shininess);
}

vec4 add_light_specular(in vec3 normal, in vec3 light_dir, in vec3 eye_pos, in int i) {
	vec3 half_vect = normalize(light_dir - normalize(eye_pos)); // Eye + L = -eye_space_pos + L
	float NdotHV = max(dot(normal, half_vect), 0.0);
	return gl_FrontLightProduct[i].specular * pow(NdotHV, gl_FrontMaterial.shininess);
}

// Note: eye space point light computation with no attenuation, or use vec3(0,0,0) for directional
vec4 add_light_comp_pos(in vec3 normal, in vec4 epos, in int i)
{
	// normalize the light's direction in eye space; for directional light, position field is actually direction
	vec3 eye_pos   = epos.xyz;
	vec3 light_dir = normalize(gl_LightSource[i].position.xyz - eye_pos);

#ifdef USE_BUMP_MAP
	float atten = length(normal); // multiply by length of eye norm to account for shadow map attenuation
	normal  = atten*apply_bump_map(light_dir);
	eye_pos = ts_pos; // convert to tangent space
#endif

#ifdef USE_LIGHT_COLORS
#ifdef USE_COLOR_IN0
	vec4 color = gl_FrontColorIn[0];
#else
	vec4 color = gl_Color;
#endif
	vec4 diffuse = color * gl_LightSource[i].diffuse;
	vec4 ambient = color * gl_LightSource[i].ambient;
#else // use light material properties
	vec4 diffuse = gl_FrontLightProduct[i].diffuse;
	vec4 ambient = gl_FrontLightProduct[i].ambient;
#endif
#ifdef USE_GOOD_SPECULAR
	vec4 specular = add_light_specular(normal, light_dir, eye_pos, i);
#else
	vec4 specular = add_light_specular_fast(normal, i);
#endif
	return (ambient + max(dot(normal, light_dir), 0.0)*diffuse + specular);
}

vec4 add_light_comp(in vec3 normal, in int i) {
	return add_light_comp_pos(normal, vec4(0,0,0,0), i);
}

vec4 add_pt_light_comp(in vec3 normal, in vec4 epos, in int i) {
	vec4 color  = add_light_comp_pos(normal, epos, i);
	float dist  = distance(gl_LightSource[i].position, epos);
	float atten = 1.0 / (gl_LightSource[i].constantAttenuation +
						 gl_LightSource[i].linearAttenuation * dist +
						 gl_LightSource[i].quadraticAttenuation * dist * dist);
	return color * atten;
}

