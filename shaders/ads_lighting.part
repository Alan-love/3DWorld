vec4 add_light_specular(in vec3 normal, in int i) {
	float NdotHV = max(dot(normal, normalize(gl_LightSource[i].halfVector.xyz)), 0.0);
	return gl_FrontLightProduct[i].specular * pow(NdotHV, gl_FrontMaterial.shininess);
}

#ifdef USE_LIGHT_COLORS

// Note: point light computation with no attenuation, or use vec3(0,0,0) for directional
vec4 add_light_comp_pos(in vec3 normal, in vec3 pos, in int i) {
	// normalize the light's direction in eye space; for directional light, position field is actually direction
	vec3 lightDir = normalize(gl_LightSource[i].position.xyz - pos);
	vec4 diffuse  = gl_Color * gl_LightSource[i].diffuse;
	vec4 ambient  = gl_Color * gl_LightSource[i].ambient;
	return (ambient + max(dot(normal, lightDir), 0.0)*diffuse + add_light_specular(normal, i));
}

vec4 add_light_comp(in vec3 normal, in int i) {
	return add_light_comp_pos(normal, vec3(0,0,0), i);
}

#else // use light material properties

// Note: point light computation with no attenuation, or use vec3(0,0,0) for directional
vec4 add_light_comp_pos(in vec3 normal, in vec3 pos, in int i) {
	// normalize the light's direction in eye space; for directional light, position field is actually direction
	vec3 lightDir = normalize(gl_LightSource[i].position.xyz - pos);
	vec4 diffuse  = max(dot(normal, lightDir), 0.0) * gl_FrontLightProduct[i].diffuse;
	return (gl_FrontLightProduct[i].ambient + add_light_specular(normal, i) + diffuse);
}

vec4 add_light_comp(in vec3 normal, in int i) {
	return add_light_comp_pos(normal, vec3(0,0,0), i);
}

#endif

vec4 add_pt_light_comp(in vec3 normal, in vec4 epos, in int i) {
	vec4 color  = add_light_comp_pos(normal, epos.xyz, i);
	float dist  = distance(gl_LightSource[i].position, epos);
	float atten = 1.0 / (gl_LightSource[i].constantAttenuation +
						 gl_LightSource[i].linearAttenuation * dist +
						 gl_LightSource[i].quadraticAttenuation * dist * dist);
	return color * atten;
}

