uniform float ambient_scale = 1.0;

vec4 get_light_specular(in vec3 normal, in vec3 light_dir, in vec3 eye_pos, in vec4 spec_color) {
	vec3 half_vect  = normalize(light_dir - normalize(eye_pos)); // Eye + L = -eye_space_pos + L
#ifdef USE_SPEC_MAP
	spec_color.rgb *= get_spec_color();
#endif
	return spec_color * pow(max(dot(normal, half_vect), 0.0), gl_FrontMaterial.shininess);
}

vec3 apply_bump_map(inout vec3 light_dir, inout vec3 eye_pos); // declare this function so we can define it later

void maybe_apply_bump_map_self_shadowed(inout vec3 normal, inout vec3 light_dir, inout vec3 eye_pos) {
#ifdef USE_BUMP_MAP
	float atten = length(normal); // multiply by length of eye norm to account for shadow map attenuation
	atten *= clamp(5.0*dot(normal/atten, light_dir), 0.0, 1.0); // fix self-shadowing
	normal = atten*apply_bump_map(light_dir, eye_pos);
#endif
}

// general case, plus hard-coded functions for light0 and light1 to help the compiler optimize

// Note: eye space point light computation with no attenuation, or use vec3(0.0) for directional
vec4 add_light_comp_pos_scaled(in vec3 normal, in vec4 epos, in int i, in float ds_scale, in float a_scale)
{
	// normalize the light's direction in eye space; for directional light, position field is actually direction
	vec3 eye_pos   = epos.xyz;
	vec3 light_dir = normalize(gl_LightSource[i].position.xyz - eye_pos);
	maybe_apply_bump_map_self_shadowed(normal, light_dir, eye_pos);
#ifdef USE_LIGHT_COLORS
#ifdef USE_COLOR_IN0
	vec4 color = gl_FrontColorIn[0];
#else
	vec4 color = gl_Color;
#endif
	vec4 diffuse = color * gl_LightSource[i].diffuse;
	vec4 ambient = color * gl_LightSource[i].ambient;
#else // use light material properties
	vec4 diffuse = gl_FrontLightProduct[i].diffuse;
	vec4 ambient = gl_FrontLightProduct[i].ambient;
#endif
#ifdef NO_SPECULAR
	vec4 specular = vec4(0.0);
#else
	vec4 specular = get_light_specular(normal, light_dir, eye_pos, gl_FrontLightProduct[i].specular);
#endif
	return (ambient_scale*a_scale*ambient + ds_scale*(max(dot(normal, light_dir), 0.0)*diffuse + specular));
}

vec4 add_light_comp_pos_scaled0(in vec3 normal, in vec4 epos, in float ds_scale, in float a_scale) {
	vec3 light_dir = normalize(gl_LightSource[0].position.xyz - epos.xyz);
	maybe_apply_bump_map_self_shadowed(normal, light_dir, epos.xyz);
#ifdef USE_LIGHT_COLORS
#ifdef USE_COLOR_IN0
	vec4 color = gl_FrontColorIn[0];
#else
	vec4 color = gl_Color;
#endif
	vec4 diffuse = color * gl_LightSource[0].diffuse;
	vec4 ambient = color * gl_LightSource[0].ambient;
#else // use light material properties
	vec4 diffuse = gl_FrontLightProduct[0].diffuse;
	vec4 ambient = gl_FrontLightProduct[0].ambient;
#endif
#ifdef NO_SPECULAR
	vec4 specular = vec4(0.0);
#else
	vec4 specular = get_light_specular(normal, light_dir, epos.xyz, gl_FrontLightProduct[0].specular);
#endif
	return (ambient_scale*a_scale*ambient + ds_scale*(max(dot(normal, light_dir), 0.0)*diffuse + specular));
}

vec4 add_light_comp_pos_scaled1(in vec3 normal, in vec4 epos, in float ds_scale, in float a_scale) {
	vec3 light_dir = normalize(gl_LightSource[1].position.xyz - epos.xyz);
	maybe_apply_bump_map_self_shadowed(normal, light_dir, epos.xyz);
#ifdef USE_LIGHT_COLORS
#ifdef USE_COLOR_IN0
	vec4 color = gl_FrontColorIn[0];
#else
	vec4 color = gl_Color;
#endif
	vec4 diffuse = color * gl_LightSource[1].diffuse;
	vec4 ambient = color * gl_LightSource[1].ambient;
#else // use light material properties
	vec4 diffuse = gl_FrontLightProduct[1].diffuse;
	vec4 ambient = gl_FrontLightProduct[1].ambient;
#endif
#ifdef NO_SPECULAR
	vec4 specular = vec4(0.0);
#else
	vec4 specular = get_light_specular(normal, light_dir, epos.xyz, gl_FrontLightProduct[1].specular);
#endif
	return (ambient_scale*a_scale*ambient + ds_scale*(max(dot(normal, light_dir), 0.0)*diffuse + specular));
}

vec4 add_light_comp_pos (in vec3 normal, in vec4 epos, in int i) {return add_light_comp_pos_scaled (normal, epos, i, 1.0, 1.0);}
vec4 add_light_comp_pos0(in vec3 normal, in vec4 epos)           {return add_light_comp_pos_scaled0(normal, epos,    1.0, 1.0);}
vec4 add_light_comp_pos1(in vec3 normal, in vec4 epos)           {return add_light_comp_pos_scaled1(normal, epos,    1.0, 1.0);}

vec4 add_light_comp (in vec3 normal, in int i) {return add_light_comp_pos (normal, vec4(0.0), i);}
vec4 add_light_comp0(in vec3 normal)           {return add_light_comp_pos0(normal, vec4(0.0)   );}
vec4 add_light_comp1(in vec3 normal)           {return add_light_comp_pos1(normal, vec4(0.0)   );}


float calc_light_atten(in vec4 epos, in int i) {
	float dist  = distance(gl_LightSource[i].position, epos);
	return 1.0 / (gl_LightSource[i].constantAttenuation + gl_LightSource[i].linearAttenuation * dist + gl_LightSource[i].quadraticAttenuation * dist * dist);
}

float calc_light_atten0(in vec4 epos) {
	float dist  = distance(gl_LightSource[0].position, epos);
	return 1.0 / (gl_LightSource[0].constantAttenuation + gl_LightSource[0].linearAttenuation * dist + gl_LightSource[0].quadraticAttenuation * dist * dist);
}

vec4 add_pt_light_comp(in vec3 normal, in vec4 epos, in int i) {
	return add_light_comp_pos(normal, epos, i) * calc_light_atten(epos, i);
}

