uniform float ambient_scale = 1.0;

vec4 calc_spec_term(in float NdotHV, in int i) {
	vec4 spec_color = gl_FrontLightProduct[i].specular;
#ifdef USE_SPEC_MAP
	spec_color.rgb *= get_spec_color();
#endif
	return spec_color * pow(NdotHV, gl_FrontMaterial.shininess);
}

vec4 get_light_specular_fast(in vec3 normal, in int i) { // unused
	float NdotHV = max(dot(normal, normalize(gl_LightSource[i].halfVector.xyz)), 0.0);
	return calc_spec_term(NdotHV, i);
}

vec4 get_light_specular(in vec3 normal, in vec3 light_dir, in vec3 eye_pos, in int i) {
	vec3 half_vect = normalize(light_dir - normalize(eye_pos)); // Eye + L = -eye_space_pos + L
	return calc_spec_term(max(dot(normal, half_vect), 0.0), i);
}

// Note: eye space point light computation with no attenuation, or use vec3(0.0) for directional
vec4 add_light_comp_pos_scaled(in vec3 normal, in vec4 epos, in int i, in float ds_scale)
{
	// normalize the light's direction in eye space; for directional light, position field is actually direction
	vec3 eye_pos   = epos.xyz;
	vec3 light_dir = normalize(gl_LightSource[i].position.xyz - eye_pos);

#ifdef USE_BUMP_MAP
	float atten = length(normal); // multiply by length of eye norm to account for shadow map attenuation
	normal = atten*apply_bump_map(light_dir, eye_pos);
#endif

#ifdef USE_LIGHT_COLORS
#ifdef USE_COLOR_IN0
	vec4 color = gl_FrontColorIn[0];
#else
	vec4 color = gl_Color;
#endif
	vec4 diffuse = color * gl_LightSource[i].diffuse;
	vec4 ambient = color * gl_LightSource[i].ambient;
#else // use light material properties
	vec4 diffuse = gl_FrontLightProduct[i].diffuse;
	vec4 ambient = gl_FrontLightProduct[i].ambient;
#endif
#ifdef NO_SPECULAR
	vec4 specular = vec4(0.0);
#else
	vec4 specular = get_light_specular(normal, light_dir, eye_pos, i);
#endif
	return (ambient_scale*ambient + ds_scale*(max(dot(normal, light_dir), 0.0)*diffuse + specular));
}

vec4 add_light_comp_pos(in vec3 normal, in vec4 epos, in int i) {
	return add_light_comp_pos_scaled(normal, epos, i, 1.0);
}

vec4 add_light_comp(in vec3 normal, in int i) {
	return add_light_comp_pos(normal, vec4(0.0), i);
}


float calc_light_atten(in vec4 epos, in int i) {
	float dist  = distance(gl_LightSource[i].position, epos);
	return 1.0 / (gl_LightSource[i].constantAttenuation + gl_LightSource[i].linearAttenuation * dist + gl_LightSource[i].quadraticAttenuation * dist * dist);
}

vec4 add_pt_light_comp(in vec3 normal, in vec4 epos, in int i) {
	return add_light_comp_pos(normal, epos, i) * calc_light_atten(epos, i);
}

