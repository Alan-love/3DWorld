uniform float ambient_scale = 1.0;
uniform vec4 specular_color = vec4(0,0,0,1); // enocded as {color.rgb, shininess}
float get_shininess() {return specular_color.a;}


struct fg_light_t {
	vec4 position;
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	vec3 atten; // {constant, linear, quadratic}
};

const int MAX_LIGHTS = 8;
uniform fg_light_t fg_LightSource[MAX_LIGHTS];


vec3 get_light_specular(in vec3 normal, in vec3 light_dir, in vec3 eye_pos, in vec3 spec_light_color) {
	vec3 half_vect = normalize(light_dir - normalize(eye_pos)); // Eye + L = -eye_space_pos + L
#ifdef USE_SPEC_MAP
	spec_light_color *= get_spec_color();
#endif
	return spec_light_color * specular_color.rgb * pow(max(dot(normal, half_vect), 0.0), get_shininess());
}

vec3 apply_bump_map(inout vec3 light_dir, inout vec3 eye_pos); // declare this function so we can define it later

void maybe_apply_bump_map_self_shadowed(inout vec3 normal, inout vec3 light_dir, inout vec3 eye_pos) {
#ifdef USE_BUMP_MAP
	float atten = length(normal); // multiply by length of eye norm to account for shadow map attenuation
	atten *= clamp(5.0*dot(normal/atten, light_dir), 0.0, 1.0); // fix self-shadowing
	normal = atten*apply_bump_map(light_dir, eye_pos);
#endif
}

// general case, plus hard-coded functions for light0 and light1 to help the compiler optimize

// Note: eye space point light computation with no attenuation, or use vec3(0.0) for directional
vec4 add_light_comp_pos_scaled(in vec3 normal, in vec4 epos, in int i, in float ds_scale, in float a_scale)
{
	// normalize the light's direction in eye space; for directional light, position field is actually direction
	vec3 light_dir = normalize(fg_LightSource[i].position.xyz - epos.xyz);
	maybe_apply_bump_map_self_shadowed(normal, light_dir, epos.xyz);
	vec3 diffuse = (gl_Color * fg_LightSource[i].diffuse).rgb;
	vec3 ambient = (gl_Color * fg_LightSource[i].ambient).rgb;
#ifdef NO_SPECULAR
	vec3 specular = vec3(0.0);
#else
	vec3 specular = get_light_specular(normal, light_dir, epos.xyz, fg_LightSource[i].specular.rgb);
#endif
	return vec4((ambient_scale*a_scale*ambient + ds_scale*(max(dot(normal, light_dir), 0.0)*diffuse + specular)), gl_Color.a);
}

vec4 add_light_comp_pos_scaled0(in vec3 normal, in vec4 epos, in float ds_scale, in float a_scale) {
	vec3 light_dir = normalize(fg_LightSource[0].position.xyz - epos.xyz);
	maybe_apply_bump_map_self_shadowed(normal, light_dir, epos.xyz);
	vec3 diffuse = (gl_Color * fg_LightSource[0].diffuse).rgb;
	vec3 ambient = (gl_Color * fg_LightSource[0].ambient).rgb;
#ifdef NO_SPECULAR
	vec3 specular = vec3(0.0);
#else
	vec3 specular = get_light_specular(normal, light_dir, epos.xyz, fg_LightSource[0].specular.rgb);
#endif
	return vec4((ambient_scale*a_scale*ambient + ds_scale*(max(dot(normal, light_dir), 0.0)*diffuse + specular)), gl_Color.a);
}

vec4 add_light_comp_pos_scaled1(in vec3 normal, in vec4 epos, in float ds_scale, in float a_scale) {
	vec3 light_dir = normalize(fg_LightSource[1].position.xyz - epos.xyz);
	maybe_apply_bump_map_self_shadowed(normal, light_dir, epos.xyz);
	vec3 diffuse = (gl_Color * fg_LightSource[1].diffuse).rgb;
	vec3 ambient = (gl_Color * fg_LightSource[1].ambient).rgb;
#ifdef NO_SPECULAR
	vec3 specular = vec3(0.0);
#else
	vec3 specular = get_light_specular(normal, light_dir, epos.xyz, fg_LightSource[1].specular.rgb);
#endif
	return vec4((ambient_scale*a_scale*ambient + ds_scale*(max(dot(normal, light_dir), 0.0)*diffuse + specular)), gl_Color.a);
}

vec4 add_light_comp_pos (in vec3 normal, in vec4 epos, in int i) {return add_light_comp_pos_scaled (normal, epos, i, 1.0, 1.0);}
vec4 add_light_comp_pos0(in vec3 normal, in vec4 epos)           {return add_light_comp_pos_scaled0(normal, epos,    1.0, 1.0);}
vec4 add_light_comp_pos1(in vec3 normal, in vec4 epos)           {return add_light_comp_pos_scaled1(normal, epos,    1.0, 1.0);}

vec4 add_light_comp (in vec3 normal, in int i) {return add_light_comp_pos (normal, vec4(0.0), i);}
vec4 add_light_comp0(in vec3 normal)           {return add_light_comp_pos0(normal, vec4(0.0)   );}
vec4 add_light_comp1(in vec3 normal)           {return add_light_comp_pos1(normal, vec4(0.0)   );}


float calc_light_atten(in vec4 epos, in int i) {
	float dist = distance(fg_LightSource[i].position, epos);
	return 1.0 / dot(fg_LightSource[i].atten, vec3(1.0, dist, dist*dist));
}

float calc_light_atten0(in vec4 epos) {
	float dist = distance(fg_LightSource[0].position, epos);
	return 1.0 / dot(fg_LightSource[0].atten, vec3(1.0, dist, dist*dist));
}

vec4 add_pt_light_comp(in vec3 normal, in vec4 epos, in int i) {
	return add_light_comp_pos(normal, epos, i) * calc_light_atten(epos, i);
}

