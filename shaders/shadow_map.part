uniform float z_bias = 0.0;
uniform float norm_bias_scale = 10.0;
uniform float sm_scale0, sm_scale1;
uniform int sm_tu_id0, sm_tu_id1;

#ifdef SMAP_MODE0
uniform sampler2D sm_tex0, sm_tex1;

// Note: normal is unused here
float get_shadow_map_weight(in vec4 pos, in vec3 normal, in float sm_scale, in int sm_tu_id, in sampler2D sm_tex) {
	vec4 shadow_coord = gl_TextureMatrix[sm_tu_id] * pos;
	shadow_coord /= shadow_coord.w;
	shadow_coord.z -= z_bias; // Used to lower moiré pattern and self-shadowing
	float dist = texture2D(sm_tex, shadow_coord.st).z;
	return ((dist < shadow_coord.z) ? 0.0 : sm_scale);
}

#else
uniform sampler2DShadow sm_tex0, sm_tex1;

float get_shadow_map_weight(in vec4 pos, in vec3 normal, in float sm_scale, in int sm_tu_id, in sampler2DShadow sm_tex) {
	vec4 shadow_coord = gl_TextureMatrix[sm_tu_id] * (pos + norm_bias_scale*z_bias*vec4(normal, 0.0));
	return sm_scale*shadow2DProj(sm_tex, shadow_coord + vec4(0, 0, -z_bias*shadow_coord.w, 0)).r;
}
#endif

float get_shadow_map_weight_light0(in vec4 pos, in vec3 normal) {
	return get_shadow_map_weight(pos, normal, sm_scale0, sm_tu_id0, sm_tex0);
}
float get_shadow_map_weight_light1(in vec4 pos, in vec3 normal) {
	return get_shadow_map_weight(pos, normal, sm_scale1, sm_tu_id1, sm_tex1);
}

vec4 add_light_comp_pos_smap_light0(in vec3 normal, in vec4 epos) {
	//if (dot((gl_LightSource[0].position.xyz - epos.xyz), n) > 0.0) {} // facing the light
	if (use_shadow_map) {normal *= get_shadow_map_weight_light0(epos, normal);}
	return add_light_comp_pos(normal, epos, 0);
}
vec4 add_light_comp_pos_smap_light1(in vec3 normal, in vec4 epos) {
	if (use_shadow_map) {normal *= get_shadow_map_weight_light1(epos, normal);}
	return add_light_comp_pos(normal, epos, 1);
}
