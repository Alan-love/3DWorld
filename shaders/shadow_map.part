uniform float z_bias          = 0.0;
uniform float norm_bias_scale = 10.0;
uniform float pcf_offset      = 0.01;
uniform float sm_scale0, sm_scale1;
uniform sampler2DShadow sm_tex0, sm_tex1;
uniform mat4 smap_matrix0, smap_matrix1;

float calc_shadow_pcf(in sampler2DShadow sm_tex, in vec4 shadow_coord) {
	float ret = 0.0;
	for (int x = -1; x <= 1; ++x) {
		for (int y = -1; y <= 1; ++y) {ret += textureProj(sm_tex, shadow_coord+vec4(pcf_offset*x, pcf_offset*y, 0, 0));}
	}
	return ret/9.0; // 9-tap PCF
}

// pos and normal are in eye space
float get_shadow_map_weight(in vec4 pos, in vec3 normal, in float sm_scale, in mat4 matrix, in sampler2DShadow sm_tex, in vec3 lpos) {
#ifndef NO_SMAP_NORMAL_OFFSET
#ifdef DYNAMIC_SMAP_BIAS
	pos.xyz += norm_bias_scale*tan(acos(max(0.05, dot(normal, normalize(lpos)))))*z_bias*normal;
#else
	pos.xyz += norm_bias_scale*z_bias*normal;
	//pos.xyz += norm_bias_scale*z_bias*normalize(fg_ModelViewMatrixInverse[3].xyz - pos.xyz); // world space view vector
#endif
#endif
	vec4 shadow_coord = matrix * pos;
	shadow_coord.z += -z_bias*shadow_coord.w;
#ifndef NO_SHADOW_PCF
	return sm_scale*calc_shadow_pcf(sm_tex, shadow_coord);
#else
	return sm_scale*textureProj(sm_tex, shadow_coord);
#endif
	// for exponential shadow map, disable the call to set_shadow_tex_params() in C++ and change sampler2DShadow to sampler2D
	//return sm_scale*exp(min(0.0, 500.0*(texture(sm_tex, shadow_coord.xy/shadow_coord.w).r - (shadow_coord.z/shadow_coord.w - z_bias))));
}

float get_shadow_map_weight_light0_no_bias(in vec4 pos) {
#if 0
	return sm_scale0*calc_shadow_pcf(sm_tex0, (smap_matrix0 * pos));
#else
	return sm_scale0*textureProj(sm_tex0, (smap_matrix0 * pos));
#endif
}
float get_shadow_map_weight_light0(in vec4 pos, in vec3 normal) {
	return get_shadow_map_weight(pos, normal, sm_scale0, smap_matrix0, sm_tex0, fg_LightSource[0].position.xyz);
}
float get_shadow_map_weight_light1(in vec4 pos, in vec3 normal) {
	return get_shadow_map_weight(pos, normal, sm_scale1, smap_matrix1, sm_tex1, fg_LightSource[1].position.xyz);
}

vec4 add_light_comp_pos_smap_light0(in vec3 normal, in vec4 epos) {
	if (use_shadow_map) {normal *= get_shadow_map_weight_light0(epos, normal);}
	return add_light_comp_pos0(normal, epos);
}
vec4 add_light_comp_pos_smap_light1(in vec3 normal, in vec4 epos) {
	if (use_shadow_map) {normal *= get_shadow_map_weight_light1(epos, normal);}
	return add_light_comp_pos1(normal, epos);
}

